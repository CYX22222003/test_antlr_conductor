export type Type =
  | "num"
  | "bool"
  | "string"
  | { type: "function"; params: Type[]; returnType: Type }
  | null
  | "undefined-CYX";

export type ParameterType = {
  name: string;
  type: Type;
};

export class Environment {
  private symbols: Map<string, Type> = new Map();
  public parent: Environment = null;

  public declare(name: string, type: Type): void {
    if (this.symbols.has(name)) {
      throw new Error(`Symbol '${name}' is already declared in this scope.`);
    }
    this.symbols.set(name, type);
  }

  public lookup(name: string): Type | null {
    if (this.symbols.has(name)) {
      return this.symbols.get(name)!;
    } else if (this.parent) {
      return this.parent.lookup(name);
    } else {
      return null;
    }
  }
}

export type TypeOwnership = {
  type: Type;
  ownershipFlag?: boolean;
  referenceFlag?: boolean;
  mutableFlag?: boolean;
  borrowedFlag?: boolean;
  borrowedFrom?: TypeOwnership;
  paramsTypeOwnership?: TypeOwnership[];
  returnTypeOwnership?: TypeOwnership;
};

export type ParameterTypeOwnership = {
  name: string;
  typeOwnership: TypeOwnership;
};

export class OwnershipEnvironment {
  public symbols: Map<string, TypeOwnership> = new Map();
  public parent: OwnershipEnvironment = null;

  public declare(name: string, type: TypeOwnership): void {
    if (this.symbols.has(name)) {
      throw new Error(`Symbol '${name}' is already declared in this scope.`);
    }
    this.symbols.set(name, type);
  }

  public lookup(name: string): TypeOwnership | null {
    if (this.symbols.has(name)) {
      return this.symbols.get(name)!;
    } else if (this.parent) {
      return this.parent.lookup(name);
    } else {
      return null;
    }
  }

  public isInClosestEnvironment(name: string): boolean {
    return this.symbols.has(name);
  }
}

// The following code is generated by ChatGPT AI (GPT-4o) copilot with prompt:
//
// "Help me to write a helper function to deep clonse the OwnershipEnvironment"

export function deepCloneOwnershipEnvironment(env: OwnershipEnvironment): OwnershipEnvironment {
  const clonedEnv = new OwnershipEnvironment();
  env.symbols.forEach((value, key) => {
    clonedEnv.declare(key, deepCloneTypeOwnership(value));
  });
  if (env.parent) {
    clonedEnv.parent = deepCloneOwnershipEnvironment(env.parent);
  }
  return clonedEnv;
}

function deepCloneTypeOwnership(typeOwnership: TypeOwnership): TypeOwnership {
  return {
    type: typeOwnership.type,
    ownershipFlag: typeOwnership.ownershipFlag,
    referenceFlag: typeOwnership.referenceFlag,
    paramsTypeOwnership: typeOwnership.paramsTypeOwnership
      ? typeOwnership.paramsTypeOwnership.map(deepCloneTypeOwnership)
      : undefined,
    returnTypeOwnership: typeOwnership.returnTypeOwnership
      ? deepCloneTypeOwnership(typeOwnership.returnTypeOwnership)
      : undefined,
  };
}

// The following code is generated by ChatGPT AI (GPT-4o) copilot with prompt:
//
// "Add another function to merge two TypeOwnership environment. They should have same number of parents.
// If there is a key value pair existing in both of the environment, take the conjunction of the onwershipFlag,
// the rest assume to be the same."

export function mergeOwnershipEnvironments(
  env1: OwnershipEnvironment,
  env2: OwnershipEnvironment
): OwnershipEnvironment {
  if ((env1.parent && !env2.parent) || (!env1.parent && env2.parent)) {
    throw new Error("Both environments must have the same number of parents.");
  }

  const mergedEnv = new OwnershipEnvironment();

  env1.symbols.forEach((value, key) => {
    if (env2.symbols.has(key)) {
      const mergedTypeOwnership = mergeTypeOwnership(value, env2.symbols.get(key)!);
      mergedEnv.declare(key, mergedTypeOwnership);
    } else {
      mergedEnv.declare(key, value);
    }
  });

  env2.symbols.forEach((value, key) => {
    if (!env1.symbols.has(key)) {
      mergedEnv.declare(key, value);
    }
  });

  if (env1.parent && env2.parent) {
    mergedEnv.parent = mergeOwnershipEnvironments(env1.parent, env2.parent);
  }

  return mergedEnv;
}

function mergeTypeOwnership(type1: TypeOwnership, type2: TypeOwnership): TypeOwnership {
  if (type1.type !== type2.type) {
    throw new Error("Type mismatch while merging TypeOwnership.");
  }

  return {
    type: type1.type,
    ownershipFlag: type1.ownershipFlag && type2.ownershipFlag,
    referenceFlag: type1.referenceFlag, // Assuming referenceFlag remains the same
    paramsTypeOwnership: type1.paramsTypeOwnership, // Assuming paramsTypeOwnership remains the same
    returnTypeOwnership: type1.returnTypeOwnership, // Assuming returnTypeOwnership remains the same
  };
}
